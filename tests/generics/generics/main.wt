/*
 No runtime tests, only compile time.
*/

/// Type generics
type Mammoth[T] {
    value: Iceberg[T]
}
type Iceberg[T] {
    value: T
}
fn test1() {
    let a: Mammoth[int] = Mammoth(Iceberg(3))
}

/// Type generics with functions
type Apply[T] {
    function: fn(T): T
}
fn test2() {
    let a: Apply[int] = Apply(fn(a: int): int {
        a
    });
}

/// Function generics
fn a[T](a: T): T = a
fn test3[V](v: V): V {
    let annotated: fn(V): V = a;
    annotated(v)
}

/// Simple function generics
fn b[T](a: T): T = a
fn test4() {
    b("hello");
    b(123);
}

/// Simple function generics 2
fn c[T](a: T): T = a
fn test5() {
    let a = c;
    a(3);
    // a("hello"); -- should produce error
}

/// Enum generics
enum Result[V, E] {
    Ok(value: V),
    Error(error: E)
}
fn test6() {
    let a = Result.Ok(3);
    a = Result.Error(false);
    let b: Result[int, bool] = a;
}
