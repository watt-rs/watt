/// Import
use crate::{
    inference::cause::Cause,
    pretty::Pretty,
    typ::{
        cx::InferCx,
        typ::{TyVar, Typ},
    },
};
use id_arena::Id;
use tracing::instrument;
use watt_common::{bail, skip};

/// An error produced during coercion or unification of types.
///
/// `CoercionError` represents *semantic* type errors that occur when
/// two types cannot be made equal under the rules of the type system.
///
/// These errors are generated by the unification engine and are later
/// enriched with contextual information (`Cause`, source locations,
/// etc.) before being reported to the user
///
#[derive(Debug, Clone)]
pub enum CoercionError {
    /// Represents types recursion.
    TypesRecursion,
    /// Represents types missmatch.
    TypesMissmatch,
}

/// A constraint in the type inference system.
///
/// `Coercion` represents a relationship between one or more types that must be
/// resolved during unification. These constraints are processed by the type
/// checker to ensure consistency of type expressions across the program.
///
/// # Variants
///
/// - [`Eq`] — unifies two types or type variables.
/// - [`Same`] — unifies all types within a group are same.
///
#[derive(Debug, Clone)]
pub enum Coercion {
    /// Equality of two types
    Eq(Typ, Typ),
    /// Equality of many types
    Same(Vec<Typ>),
}

/// Solves a coercion, dispatching to `eq` or `same`.
///
/// # Arguments
/// * `coercion` - the type constraint to solve
///
pub fn coerce(icx: &mut InferCx, cause: Cause, coercion: Coercion) {
    // Solving coercion
    match coercion.clone() {
        Coercion::Eq(t1, t2) => eq(icx, &cause, t1, t2),
        Coercion::Same(items) => same(icx, &cause, items),
    }
}

/// Solves an `Eq(t1, t2)` coercion.
#[instrument(skip(icx), level = "trace")]
fn eq(icx: &mut InferCx, cause: &Cause, t1: Typ, t2: Typ) {
    // Processing unification
    let (p1, p2) = (t1.pretty(icx), t2.pretty(icx));
    match unify(icx, t1, t2) {
        Ok(_) => skip!(),
        Err(error) => bail!(cause.clone().into_typeck_error(error, p1, p2)),
    }
}

/// Solves a `Same(items)` coercion,
/// unifying all elements with the first one.
#[instrument(skip(icx), level = "trace")]
fn same(icx: &mut InferCx, cause: &Cause, mut items: Vec<Typ>) {
    // Retrieving first information
    let t1 = items.remove(0);
    // Coerce `eq` with others
    for t2 in items {
        eq(icx, cause, t1.clone(), t2);
    }
}

/// Core method to unify two types.
///
fn unify(icx: &mut InferCx, t1: Typ, t2: Typ) -> Result<(), CoercionError> {
    // Applying substs
    let t1 = icx.apply(t1);
    let t2 = icx.apply(t2);
    // Unifying
    if t1 != t2 {
        match (&t1, &t2) {
            (Typ::Var(a), Typ::Var(b)) => {
                if a != b {
                    icx.substitute(*a, t2.clone());
                }
                Ok(())
            }
            (Typ::Var(a), b) | (b, Typ::Var(a)) => {
                if occurs(icx, *a, b) {
                    Err(CoercionError::TypesRecursion)
                } else {
                    icx.substitute(*a, b.clone());
                    Ok(())
                }
            }
            (Typ::Struct(id1, _), Typ::Struct(id2, _)) => {
                if id1 == id2 {
                    t1.fields(icx)
                        .into_iter()
                        .zip(t2.fields(icx))
                        .try_for_each(|(a, b)| unify(icx, a.typ.clone(), b.typ.clone()))
                } else {
                    Err(CoercionError::TypesMissmatch)
                }
            }
            (Typ::Enum(def1, _), Typ::Enum(def2, _)) => {
                if def1 == def2 {
                    t1.variants(icx)
                        .into_iter()
                        .zip(t2.variants(icx))
                        .try_for_each(|(v1, v2)| {
                            v1.fields
                                .iter()
                                .zip(v2.fields)
                                .try_for_each(|(a, b)| unify(icx, a.typ.clone(), b.typ.clone()))
                        })
                } else {
                    Err(CoercionError::TypesMissmatch)
                }
            }
            (Typ::Function(_, _), Typ::Function(_, _)) => {
                t1.params(icx)
                    .into_iter()
                    .zip(t2.params(icx))
                    .try_for_each(|(p1, p2)| unify(icx, p1.typ.clone(), p2.typ.clone()))?;
                let r1 = t1.ret(icx);
                let r2 = t2.ret(icx);
                unify(icx, r1, r2)
            }
            _ => Err(CoercionError::TypesMissmatch),
        }
    } else {
        Ok(())
    }
}

/// Occurs check — ensures that a type variable does not appear within itself.
///
/// # Arguments
/// * `own` — the type variable identifier
/// * `t` — the type to check for occurrence
///
/// # Returns
/// `true` if the type variable occurs in itself (infinite type), otherwise `false`
///
fn occurs(icx: &mut InferCx, own: Id<TyVar>, t: &Typ) -> bool {
    let t = icx.apply(t.clone());

    match t {
        Typ::Var(id) => {
            // variable occurs in itself → infinite type
            id == own
        }
        it @ Typ::Function(_, _) => {
            it.params(icx).into_iter().any(|p| occurs(icx, own, &p.typ)) || {
                let r = it.ret(icx);
                occurs(icx, own, &r)
            }
        }
        it @ Typ::Struct(_, _) => it.fields(icx).into_iter().any(|f| occurs(icx, own, &f.typ)),
        it @ Typ::Enum(_, _) => it
            .variants(icx)
            .iter()
            .any(|v| v.fields.iter().any(|f| occurs(icx, own, &f.typ))),
        Typ::Generic(_) | Typ::Prelude(_) | Typ::Unit => false,
    }
}
