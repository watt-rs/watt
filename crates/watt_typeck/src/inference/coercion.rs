/// Import
use crate::{
    errors::{TypeckError, TypeckRelated},
    typ::{
        cx::InferCx,
        typ::{TyVar, Typ},
    },
};
use id_arena::Id;
use tracing::instrument;
use watt_common::{address::Address, bail, skip};

/// A cause describing *why* a type constraint was introduced.
///
/// `Cause` is used exclusively for diagnostics. It does **not** affect
/// type inference or unification logic, but is attached to constraints
/// in order to produce precise and user-friendly error messages.
///
/// In other words, it answers the question:
/// > "In which language construct did this type check occur?"
///
/// This design mirrors the approach used in `rustc`, where the
/// unification engine is context-agnostic, while error reporting
/// is enriched using an explicit cause stack.
///
#[derive(Debug, Clone)]
pub enum Cause<'a> {
    /// A type constraint originating from a function call argument.
    ///
    /// Example:
    /// ```watt
    /// foo(1, true)
    ///        ^^^^
    /// ```
    ///
    FunctionArgument(&'a Address),

    /// A type constraint originating from a struct creation argument.
    ///
    /// Example:
    /// ```watt
    /// Struct(arg1, arg2)
    ///              ^^^^
    /// ```
    ///
    StructArgument(&'a Address),

    /// A type constraint originating from a variant creation argument.
    ///
    /// Example:
    /// ```watt
    /// Enum.Variant(arg1, arg2)
    ///              ^^^^
    /// ```
    ///
    VariantArgument(&'a Address),

    /// A type constraint originating from an assignment expression.
    ///
    /// Example:
    /// ```watt
    /// let x: int = expr;
    /// ```
    ///
    Assignment(&'a Address),

    /// A type constraint originating from an return type and block type match check.
    ///
    /// Example:
    /// ```watt
    /// fn a(): int {
    ///     325
    /// }
    /// ```
    ///
    Return(&'a Address, &'a Address),

    /// A type constraint originating from an pattern type and matchable type match check.
    ///
    /// Example:
    /// ```watt
    /// match option {
    ///       ^^^^^^
    ///     Option.Some(value) -> value,
    ///     ^^^^^^^^^^^^^^^^^
    ///     Option.None -> todo
    /// }
    /// ```
    ///
    Pattern(&'a Address, &'a Address),

    /// A type constraint originating from an branch types match check.
    ///
    /// Example:
    /// ```watt
    /// match option {
    /// ^^^^^
    ///     Option.Some(value) -> value,
    ///                           ^^^^^
    ///     Option.None -> todo
    /// }
    /// ```
    ///
    Branch(&'a Address, &'a Address),
}

/// An error produced during coercion or unification of types.
///
/// `CoercionError` represents *semantic* type errors that occur when
/// two types cannot be made equal under the rules of the type system.
///
/// These errors are generated by the unification engine and are later
/// enriched with contextual information (`Cause`, source locations,
/// etc.) before being reported to the user
///
#[derive(Debug, Clone)]
pub enum CoercionError {
    /// Represents types recursion.
    TypesRecursion,
    /// Represents types missmatch.
    TypesMissmatch,
}

/// A constraint in the type inference system.
///
/// `Coercion` represents a relationship between one or more types that must be
/// resolved during unification. These constraints are processed by the type
/// checker to ensure consistency of type expressions across the program.
///
/// # Variants
///
/// - [`Eq`] — unifies two types or type variables.
/// - [`Same`] — unifies all types within a group are same.
///
#[derive(Debug, Clone)]
pub enum Coercion {
    /// Equality of two types
    Eq(Typ, Typ),
    /// Equality of many types
    Same(Vec<Typ>),
}

/// Solves a coercion, dispatching to `eq` or `same`.
///
/// # Arguments
/// * `coercion` - the type constraint to solve
///
pub fn coerce(icx: &mut InferCx, cause: Cause, coercion: Coercion) {
    // Solving coercion
    match coercion.clone() {
        Coercion::Eq(t1, t2) => eq(icx, &cause, t1, t2),
        Coercion::Same(items) => same(icx, &cause, items),
    }
}

/// Solves an `Eq(t1, t2)` coercion.
#[instrument(skip(icx), level = "trace")]
fn eq(icx: &mut InferCx, cause: &Cause, t1: Typ, t2: Typ) {
    // Processing unification
    let (p1, p2) = (t1.pretty(icx), t2.pretty(icx));
    match unify(icx, t1, t2) {
        Ok(_) => skip!(),
        Err(error) => match error {
            CoercionError::TypesRecursion => todo!(),
            CoercionError::TypesMissmatch => match cause.clone() {
                Cause::FunctionArgument(address) => bail!(TypeckError::TypesMissmatch {
                    related: vec![TypeckRelated::Here {
                        src: address.source.clone(),
                        span: address.span.clone().into()
                    }],
                    expected: p1,
                    got: p2
                }),
                Cause::StructArgument(address) => bail!(TypeckError::TypesMissmatch {
                    related: vec![TypeckRelated::Here {
                        src: address.source.clone(),
                        span: address.span.clone().into()
                    }],
                    expected: p1,
                    got: p2
                }),
                Cause::VariantArgument(address) => bail!(TypeckError::TypesMissmatch {
                    related: vec![TypeckRelated::Here {
                        src: address.source.clone(),
                        span: address.span.clone().into()
                    }],
                    expected: p1,
                    got: p2
                }),
                Cause::Assignment(address) => {
                    bail!(TypeckError::TypesMissmatch {
                        related: vec![TypeckRelated::Here {
                            src: address.source.clone(),
                            span: address.span.clone().into()
                        }],
                        expected: p1,
                        got: p2
                    })
                }
                Cause::Return(body, ret) => {
                    bail!(TypeckError::TypesMissmatch {
                        related: vec![
                            TypeckRelated::ThisType {
                                src: body.source.clone(),
                                span: body.span.clone().into(),
                                t: p1.clone()
                            },
                            TypeckRelated::ThisType {
                                src: ret.source.clone(),
                                span: ret.span.clone().into(),
                                t: p2.clone()
                            }
                        ],
                        expected: p1,
                        got: p2
                    })
                }
                Cause::Pattern(matchable, pattern) => {
                    bail!(TypeckError::TypesMissmatch {
                        related: vec![
                            TypeckRelated::ThisType {
                                src: matchable.source.clone(),
                                span: matchable.span.clone().into(),
                                t: p1.clone()
                            },
                            TypeckRelated::ThisType {
                                src: pattern.source.clone(),
                                span: pattern.span.clone().into(),
                                t: p2.clone()
                            }
                        ],
                        expected: p1,
                        got: p2
                    })
                }
                Cause::Branch(match_, case) => {
                    bail!(TypeckError::TypesMissmatch {
                        related: vec![
                            TypeckRelated::ThisType {
                                src: match_.source.clone(),
                                span: match_.span.clone().into(),
                                t: p1.clone()
                            },
                            TypeckRelated::ThisType {
                                src: case.source.clone(),
                                span: case.span.clone().into(),
                                t: p2.clone()
                            }
                        ],
                        expected: p1,
                        got: p2
                    })
                }
            },
        },
    }
}

/// Solves a `Same(items)` coercion,
/// unifying all elements with the first one.
#[instrument(skip(icx), level = "trace")]
fn same(icx: &mut InferCx, cause: &Cause, mut items: Vec<Typ>) {
    // Retrieving first information
    let t1 = items.remove(0);
    // Coerce `eq` with others
    for t2 in items {
        eq(icx, cause, t1.clone(), t2);
    }
}

/// Core method to unify two types.
///
fn unify(icx: &mut InferCx, t1: Typ, t2: Typ) -> Result<(), CoercionError> {
    // Applying substs
    let t1 = icx.apply(t1);
    let t2 = icx.apply(t2);
    // Unifying
    if t1 != t2 {
        match (&t1, &t2) {
            (Typ::Var(a), Typ::Var(b)) => {
                if a != b {
                    icx.substitute(*a, t2.clone());
                }
                Ok(())
            }
            (Typ::Var(a), b) | (b, Typ::Var(a)) => {
                if occurs(icx, *a, b) {
                    Err(CoercionError::TypesRecursion)
                } else {
                    icx.substitute(*a, b.clone());
                    Ok(())
                }
            }
            (Typ::Struct(id1, _), Typ::Struct(id2, _)) => {
                if id1 == id2 {
                    t1.fields(icx)
                        .into_iter()
                        .zip(t2.fields(icx))
                        .try_for_each(|(a, b)| unify(icx, a.typ.clone(), b.typ.clone()))
                } else {
                    Err(CoercionError::TypesMissmatch)
                }
            }
            (Typ::Enum(def1, _), Typ::Enum(def2, _)) => {
                if def1 == def2 {
                    t1.variants(icx)
                        .into_iter()
                        .zip(t2.variants(icx))
                        .try_for_each(|(v1, v2)| {
                            v1.fields
                                .iter()
                                .zip(v2.fields)
                                .try_for_each(|(a, b)| unify(icx, a.typ.clone(), b.typ.clone()))
                        })
                } else {
                    Err(CoercionError::TypesMissmatch)
                }
            }
            (Typ::Function(_, _), Typ::Function(_, _)) => {
                t1.params(icx)
                    .into_iter()
                    .zip(t2.params(icx))
                    .try_for_each(|(p1, p2)| unify(icx, p1.typ.clone(), p2.typ.clone()))?;
                let r1 = t1.ret(icx);
                let r2 = t2.ret(icx);
                unify(icx, r1, r2)
            }
            _ => Err(CoercionError::TypesMissmatch),
        }
    } else {
        Ok(())
    }
}

/// Occurs check — ensures that a type variable does not appear within itself.
///
/// # Arguments
/// * `own` — the type variable identifier
/// * `t` — the type to check for occurrence
///
/// # Returns
/// `true` if the type variable occurs in itself (infinite type), otherwise `false`
///
fn occurs(icx: &mut InferCx, own: Id<TyVar>, t: &Typ) -> bool {
    let t = icx.apply(t.clone());

    match t {
        Typ::Var(id) => {
            // variable occurs in itself → infinite type
            id == own
        }
        it @ Typ::Function(_, _) => {
            it.params(icx).into_iter().any(|p| occurs(icx, own, &p.typ)) || {
                let r = it.ret(icx);
                occurs(icx, own, &r)
            }
        }
        it @ Typ::Struct(_, _) => it.fields(icx).into_iter().any(|f| occurs(icx, own, &f.typ)),
        it @ Typ::Enum(_, _) => it
            .variants(icx)
            .iter()
            .any(|v| v.fields.iter().any(|f| occurs(icx, own, &f.typ))),
        Typ::Generic(_) | Typ::Prelude(_) | Typ::Unit => false,
    }
}
